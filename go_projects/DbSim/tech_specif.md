# TypeBox — универсальное мини‑хранилище (подробное задание)


## Краткая идея

Реализовать мини‑СУБД `TypeBox`, которая хранит значения разных типов по строковым ключам и выполняет команды из `STDIN`. Некоторые команды выводят результат в `STDOUT`.

Решение должно быть аккуратно спроектировано: использовать интерфейс `Printable`, структуры `ObjectValue` и `ListValue`, и объект `TypeBox` с методами, инкапсулирующими логику команд.

---

## Поддерживаемые типы данных

В `TypeBox` можно хранить:

* `int` — целые числа (поддерживаем 32‑битный диапазон при вводе);
* `float64` — числа с плавающей точкой;
* `string` — строки без пробелов;
* `ObjectValue` — объект, обёртка над `map[string]interface{}`;
* `ListValue` — список, обёртка над `[]interface{}`.

Внутреннее хранилище (`store`) должно быть типа `map[string]interface{}` — все значения хранятся там.

---

## Формат ввода

Первая строка входа:

```
Q
```

`Q` — число команд (1 ≤ Q ≤ 1000).

Далее идут `Q` строк — команды одного из описанных ниже видов. Некоторые команды занимают несколько строк (например, `OBJECT`).

---

## Команды

### 1) SET

```
SET key TYPE value
```

Устанавливает скалярное значение (`INT`, `FLOAT` или `STRING`) по строковому `key`.

* `key` — строка без пробелов;
* `TYPE` ∈ `{INT, FLOAT, STRING}`;
* `value` — формат зависит от `TYPE`:

  * `INT` — целое число (в пределах 32‑битного int при вводе);
  * `FLOAT` — дробное число (`3.14`, `0.5`, `10.0` и т.д.);
  * `STRING` — строка без пробелов.

**Примеры:**

```
SET age INT 25
SET pi FLOAT 3.14
SET name STRING Alice
```

---

### 2) OBJECT

Создаёт объект и сохраняет его по ключу.

Формат:

```
OBJECT key n
field1 TYPE1 value1
field2 TYPE2 value2
...
fieldN TYPEN valueN
```

* `key` — имя ключа для объекта;
* `n` — число полей объекта (1 ≤ n ≤ 20);
* далее `n` строк, каждая: `fieldName TYPE value`, где `TYPE` — `INT`, `FLOAT` или `STRING`.

Внутри объект хранится как `ObjectValue{ Data: map[string]interface{} }`.

**Пример:**

```
OBJECT person 2
age INT 30
city STRING London
```

---

### 3) PUSH

```
PUSH key TYPE value
```

Добавляет значение в список по ключу `key`. Поведение — подробно:

1. Если ключа `key` нет в `store`: создаётся новый список `ListValue` с одним элементом (со значением, полученным из `TYPE` и `value`) и сохраняется по `key`.
2. Если по `key` уже лежит список (`ListValue`) — новое значение дописывается в конец этого списка.
3. Если по `key` лежит значение другого типа (не `ListValue`) — создаётся новый список:

   * сначала в него помещается старое значение (то, что было под `key`),
   * затем — новое значение,
   * список сохраняется по `key` как `ListValue`.

Значение определяется по `TYPE` так же, как в `SET`.

**Примеры:**

```
PUSH list INT 10
PUSH list STRING hello
PUSH list FLOAT 3.5
```

После этих трёх команд `list` будет представлять `ListValue{ Data: []interface{}{10, "hello", 3.5} }`.

---

### 4) MERGE

```
MERGE target source
```

Сливает поля объекта `source` в объект `target`:

* по ключам `target` и `source` в `store` должны лежать объекты (`ObjectValue`);
* копируются все поля из `source` в `target` (в `target` перезаписываются поля с одинаковыми именами);
* если `target` или `source` отсутствует в `store` или по одному из ключей лежит не объект — команда игнорируется (ничего не делает);
* при успешном MERGE результат сохраняется в `target` (в виде `ObjectValue`).

Ничего не выводится в `STDOUT`.

**Важно:** MERGE работает **только** с `ObjectValue` — другие типы игнорируются.

---

### 5) PRINT

```
PRINT key
```

Вывести значение, хранящееся под `key`, в каноническом текстовом формате. Если `key` не существует — вывести `null`.

Формат вывода по типам:

* `INT` → просто число, например: `42`;
* `FLOAT` → выводить с использованием `strconv.FormatFloat(value, 'f', -1, 64)`, например: `3.14` или `10` (в формате, который даёт указанная функция);
* `STRING` → строка без кавычек: `Hello`;
* `ListValue` → в виде `[v1,v2,v3]` — квадратные скобки, элементы через запятую, **без пробелов**;
* `ObjectValue` → в виде `{k1:v1,k2:v2}` — фигурные скобки, пары `ключ:значение` через запятую **без пробелов**.

Для объектов: поля должны быть отсортированы по ключу лексикографически (возрастание).

Для списков и объектов вложенные значения форматируются рекурсивно по тем же правилам.

**Примеры формата:**

* `25`
* `3.5`
* `hello`
* `[10,hello,3.5]`
* `{age:30,city:London}`

---

## Интерфейс и структуры (обязательные требования)

### Интерфейс `Printable`

Определить интерфейс:

```go
type Printable interface {
    ToString() string
}
```

Правило при выводе (для команды `PRINT` / метода `PrintKey`):

* прежде чем форматировать значение вручную, нужно проверить, реализует ли оно `Printable` (через типовое приведение `v.(Printable)`). Если да — использовать `ToString()` для получения строкового представления;
* если не реализует — обрабатывать примитивные типы (`int`, `float64`, `string`) и стандартные контейнеры (см. ниже).

### `ObjectValue`

Объявление:

```go
type ObjectValue struct {
    Data map[string]interface{}
}
```

* `ObjectValue` должен реализовать `Printable` методом `ToString()`;
* в `ToString()` ключи сортируются лексикографически; пары выводятся в формате `{k1:v1,k2:v2}` — без пробелов;
* значения полей форматируются через общий форматировщик (тот же, что используется при `PRINT`).

### `ListValue`

Объявление:

```go
type ListValue struct {
    Data []interface{}
}
```

* `ListValue` реализует `Printable` методом `ToString()`;
* `ToString()` возвращает строку формата `[v1,v2,...]` без пробелов; элементы форматируются через общий форматировщик.

---

## TypeBox — «объект БД»

Реализация БД должна быть оформлена через структуру `TypeBox`, которая инкапсулирует `store` и содержит методы для команд.

Требования:

* `TypeBox` содержит `store map[string]interface{}`;
* должен быть конструктор:

```go
func NewTypeBox() *TypeBox { ... }
```

* логика команд должна быть реализована в методах `TypeBox` (а не в `main`). Примерный API (можно менять сигнатуры, главное — разделение логики):

```go
func (tb *TypeBox) SetScalar(key, typ, raw string)
func (tb *TypeBox) SetObject(key string, fields [][3]string)
func (tb *TypeBox) PushValue(key, typ, raw string)
func (tb *TypeBox) MergeObjects(target, source string)
func (tb *TypeBox) PrintKey(key string) string
```

* `SetObject` обязан сохранять `ObjectValue`;
* `PushValue` обязан работать со `ListValue`;
* `MergeObjects` — только для объектов (`ObjectValue`), иначе игнорируется;
* `PrintKey` должен возвращать строку, используя общий форматировщик и `Printable`.

---

## Дополнительные ограничения и подсказки

* **Нельзя** использовать дженерики и пакет `encoding/json`.
* При форматировании `float64` используйте именно `strconv.FormatFloat(value, 'f', -1, 64)`.
* Для проверки типа и распаковки значений удобно использовать `type switch` и приведения типов (`.(type)`, `value.(ObjectValue)`, или `value.(*ObjectValue)` — см. реализацию на выбор).
* Внутреннее хранилище должно быть `map[string]interface{}`.
* Внимательно обрабатывай случаи отсутствия ключа: `PRINT` должен вывести `null`.
* Для `MERGE` — если один из ключей отсутствует или не объект — ничего не делать (тихая игнорирующая команда).

---

## Формат вывода

Для каждой команды `PRINT` нужно вывести одну строку в `STDOUT` с каноническим текстовым представлением значения (см. раздел «PRINT»). Ничего лишнего (отладочных сообщений) выводить нельзя.

---

## Пример

**Ввод:**

```
11
SET age INT 25
SET name STRING Alice
OBJECT person 2
age INT 30
city STRING London
PUSH list INT 10
PUSH list STRING hello
PUSH list FLOAT 3.5
MERGE person_extra person
PRINT age
PRINT list
PRINT person
PRINT unknown
```

**Ожидаемый вывод:**

```
25
[10,hello,3.5]
{age:30,city:London}
null
```

> Обрати внимание: `MERGE person_extra person` ничего не делает, поскольку `person_extra` не существует — команда игнорируется.

---

## Что тестируется (коротко)

* Корректность парсинга команд и многолинейных команд (`OBJECT`).
* Правильное представление и хранение разных типов.
* Реализация интерфейса `Printable` и его использование при выводе.
* Поведение `PUSH` при разных типах текущего значения по ключу.
* Сортировка ключей при выводе `ObjectValue`.
* Корректный формат чисел (особенно `float64`).


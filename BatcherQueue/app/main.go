/*
1. Прочитать и понять тесты (входная спецификация)
1.1. Открой файл batcher_queue_test.go.
1.2. Для каждой секции тестов выпиши требования:
когда должен срабатывать flush (по размеру / по таймауту),
гарантии: батч не превышает capacity, при Close оставшиеся элементы должны быть отправлены, Close должен дождаться завершения всех handler-ов, при ничего не добавленном — handler не вызывается, массовая загрузка должна пройти (нет потерь).
1.3. Технологии/инструменты: go test, текстовый просмотрщик (IDE или less).
Зачем: тесты — контракт; реализовать нужно именно то, что они ожидают.
2. Выбрать модель конкурентности (архитектура)
2.1. Реши, как действовать по-протоколу:
один внутренний собиратель (goroutine) читает вход и формирует текущий батч;
три триггера для флаша: достижение размера, истечение таймера, закрытие;
каждый вызов handler выполняем в отдельной gorутине (чтобы не блокировать сборщик), но при этом контролируем завершение через sync.WaitGroup.
2.2. Технологии/примитивы: goroutines, channels, select, time.Timer / time.After, sync.WaitGroup, sync.Mutex (по необходимости), generics Batcher[T any] (Go 1.18+).
Зачем: понятная модель помогает избежать утечек и гонок.
3. Определить поля структуры Batcher[T]
3.1. Выпиши необходимое состояние (список полей) — без кода просто концептуально:
канал входных элементов (чтобы Add было конкурентным и неблокирующим/контролируемым),
текущий batch (слайс) внутри сборщика,
flushSize и interval,
handler,
wg для отслеживания активных handler-ов,
сигнал завершения/закрытия (канал done или закрытие входного канала),
флаг closed (защита от добавления после Close) и mutex для флага при необходимости.
3.2. Инструменты/заметки: использовать каналы для коммуникации, а не шаримые слайсы из внешней функции.
Зачем: заранее продуманные поля упрощают реализацию и уменьшают гонки.
4. Проект поведения NewBatcher (инициализация)
4.1. Что должен делать конструктор:
создать и вернуть Batcher,
запустить внутреннюю сборочную goroutine (consumer) — она слушает канал входа и таймер и вызывает handler.
4.2. Инструменты: go routine внутри конструктора, time для таймера.
Зачем: сразу запустить жизненный цикл — чтобы Add мог просто писать в канал.
5. Проект поведения Add(items ...T)
5.1. Требования:
безопасно вызывать параллельно;
корректно обрабатывать множественные элементы за один вызов;
при добавлении после Close — реши поведение (игнорировать добавление или panic). Тесты не требуют паники — безопаснее игнорировать.
5.2. Модель: Add посылает элементы в входной канал; если канал буферизованный — Add может блокироваться при переполнении, учти это.
5.3. Инструменты/заметки: channel send, возможно проверка флага closed с mutex перед отправкой.
Зачем: Add — публичный API, должен быть простым и безопасным.
6. Внутренний алгоритм сборщика (consumer goroutine)
6.1. Логика цикла:
поддерживать текущий слайс/батч, запустить таймер при добавлении первого элемента,
в select слушать: входной канал (добавление), таймер (timeout), сигнал закрытия (закрытие входного канала / done), и реагировать на достижение flushSize.
6.2. На flush: скопировать/вынуть текущие элементы, нольнуть текущий батч, остановить/сбросить таймер, и запустить handler в новой горутине, увеличив wg перед запуском и уменьшив в конце handler-а.
6.3. При закрытии входного канала: выполнить последний flush (если есть элементы), дождаться wg и завершиться.
6.4. Инструменты: select, time.Timer (а не time.After в цикле — чтобы иметь возможность Stop() и перезапустить), sync.WaitGroup.
Зачем: это центральная часть — здесь гарантия корректности и отсутствие утечек.
7. Реализация Close()
7.1. Цель: корректно завершить агрегатор и дождаться всех запущенных handler-ов.
7.2. План:
пометить closed (чтобы Add больше не добавлял),
закрыть входной канал (или послать сигнал), чтобы consumer goroutine увидел EOF,
дождаться, пока consumer завершится (можно через дополнительный done канал или ждать, что внутренний gorутин сам вызовет wg.Wait()),
дождаться wg (ожидание завершения всех handler-ов).
7.3. Инструменты: каналы завершения, sync.WaitGroup, mutex для флага closed.
Зачем: тесты требуют graceful shutdown и ожидание handler-а.
8. Разбиение больших Add-вызовов (механика «больше чем capacity»)
8.1. Если Add получает N элементов сразу, и N > capacity, план — разбить их на несколько батчей: либо отправить в канал как последовательность элементов (consumer сам сгруппирует), либо предусмотреть в Add разбивку по части.
8.2. Выбор: проще — просто отправлять по одному в канал; это полностью переносит логику на collector. Но если нужен throughput, можно отправлять порциями.
8.3. Инструменты: задание задачи — обеспечь, чтобы тесты, где Add(1,2,3,4,5,6,7) ожидали несколько flush'ей, проходили.
Зачем: предотвращает превышение capacity.
9. Синхронизация и защита от гонок
9.1. Где возможны гонки: флаг closed, внутренний батч (если ты обрабатываешь слайс из нескольких горутин), wg — корректное использование.
9.2. Инструменты: sync.Mutex или атомики для закрытого флага; минимизируй количество операций под mutex.
9.3. Проверка: всегда запускать go test -race для обнаружения data race.
Зачем: гонки приводят к невоспроизводимым багам и падениям тестов.
10. Тестирование и отладка
10.1. Запусти тесты: go test ./... и по отдельности go test -run TestName -v.
10.2. Используй -race: go test -race ./....
10.3. При падениях — добавь логирование (временные fmt.Println или t.Log) чтобы увидеть поток: когда создаются/флашатся батчи, когда вызывается handler, когда закрывается.
10.4. Отладчик: delve (dlv test) если нужно пошагово смотреть поведение.
10.5. Lint и vet: gofmt, go vet, golangci-lint (если есть).
Зачем: быстро находить и исправлять ошибки синхронизации.
11. Итеративный план реализации (порядок действий, без кода)
11.1. Шаг 1 — подготовка: настроить среду (Go 1.18+), открыть проект в IDE (VSCode/GoLand).
11.2. Шаг 2 — написать описание полей Batcher в голове (см. пункт 3).
11.3. Шаг 3 — реализовать NewBatcher чтобы он запускал consumer goroutine и возвращал структуру. (Проверка: запускай go test, должно по-прежнему падать — ожидаемо.)
11.4. Шаг 4 — реализовать простой Add (отправка отдельных элементов в входной канал).
11.5. Шаг 5 — в consumer реализовать наращивание батча и flush по достижению flushSize. Запустить тест TestFlush_WhenBatchIsFull.
11.6. Шаг 6 — добавить таймер и flush по таймауту. Проверить TestFlush_WhenTimeoutExpires и TestFlush_NothingAdded.
11.7. Шаг 7 — обработка множественных элементов и большого потока (TestBatcher_NeverExceedsCapacity, TestFlush_MultipleBatches).
11.8. Шаг 8 — реализовать Close и graceful shutdown (проверить TestShutdown_FlushesRemainingItems, TestShutdown_WaitsForHandler).
11.9. Шаг 9 — запустить go test -race и исправить гонки.
11.10. Шаг 10 — рефакторинг: убрать лишние блокировки, добавить комментарии и gofmt.
Зачем: шаги короткие, каждая итерация — проверяемая единица.
12. Отладочные советы и типичные ошибки
12.1. Ошибка: утечка goroutine — проявляется в тестах как зависание. Причина: consumer не завершился или handler горутины не отслеживаются.
12.2. Ошибка: handler вызывается после Close (если не сделан финальный flush корректно).
12.3. Ошибка: data race на флаге closed или на слайсе батча — тест -race выявит.
12.4. Советы: всегда wg.Add(1) перед запуском handler-горутины и defer wg.Done() внутри нее. Стоп-таймер корректно (если используешь time.Timer) — не забывай читать канал таймера при Stop() если он уже сработал.
12.5. Производительность: буфер входного канала уменьшает блокировки Add при всплесках; но слишком большой буфер — больше памяти.
13. Как проверять понимание принципов (практика без кода)
13.1. Объясни вслух (или запиши) поток данных: от Add → канал → consumer → trigger → handler → wg.
13.2. Нарисуй простую диаграмму (в блоках) триггеров флаша.
13.3. Опиши 3 сценария ошибок и как их предотвратить (утечки, гонки, двойной flush).
14. Полезные ресурсы и команды
14.1. Команды:
go test -v — запуск тестов подробно;
go test -race — проверка на гонки;
go vet, gofmt, golangci-lint run.
14.2. Документация/темы для чтения: Go concurrency patterns (select, timers, channels), sync.WaitGroup, time.Timer vs time.After, generics в Go (объявление type Batcher[T any] struct{}).
Контрольный чеклист (когда закончишь)
Все тесты проходят (go test ./...).
go test -race — без data race.
Close() корректно завершает и ждёт handler-ов.
Никаких утечек goroutine при go test -run Test*.
Нет превышения flushSize в батчах.
Поведение при добавлении после Close — определено и безопасно.
*/
package main

import (
	"fmt"
	"time"

	"github.com/moguchev/stepik/4/4.6/HW/batcher"
)

func main() {
	handler := func(batch []string) {
		fmt.Println(">>> Flushed:", batch)
		time.Sleep(500 * time.Millisecond) // эмуляция долгой обработки
	}
	b := batcher.NewBatcher(5, 2*time.Second, handler)
	for i := 1; i <= 12; i++ {
		b.Add(fmt.Sprintf("event-%d", i))
		time.Sleep(300 * time.Millisecond)
	}
	// Завершаем батчер, дожидаемся flush'а и всех handler'ов
	b.Close()
	fmt.Println("Batcher gracefully shut down.")
}
